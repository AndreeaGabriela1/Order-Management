package dao;import connection.ConnectionFactory;import model.Client;import javax.swing.*;import javax.swing.table.DefaultTableModel;import java.sql.*;import java.util.ArrayList;import java.util.logging.Level;import java.util.logging.Logger;public class ClientDAO implements GenericDAO<Client> {    protected static final Logger LOGGER = Logger.getLogger(ClientDAO.class.getName());    private static final String INSERT_STATEMENT = "INSERT INTO client (id, name, email, phoneNumber, address) VALUES (?, ?, ?, ?, ?)";    private static final String FIND_STATEMENT = "SELECT * FROM Client WHERE id = ?";    private static final String UPDATE_STATEMENT = "UPDATE client SET name = ?, email = ?, phoneNumber = ?, address = ? WHERE id = ?";    private static final String DELETE_STATEMENT = "DELETE FROM client WHERE id = ?";    private static final String SELECT_ALL_STATEMENT = "SELECT * FROM Client";    @Override    public Client findById(int id) {        Client client = null;        try (Connection connection = ConnectionFactory.getConnection();             PreparedStatement statement = connection.prepareStatement(FIND_STATEMENT)) {            statement.setInt(1, id);            ResultSet resultSet = statement.executeQuery();            if (resultSet.next()) {                String name = resultSet.getString("name");                String email = resultSet.getString("email");                String phoneNumber = resultSet.getString("phoneNumber");                String address = resultSet.getString("address");                client = new Client(id, name, email, phoneNumber, address);            }        } catch (SQLException e) {            LOGGER.log(Level.WARNING, "ClientDAO:findById: " + e.getMessage());        }        return client;    }    @Override    public int insert(Client client, int value) {        int insertId = -1;        try (Connection connection = ConnectionFactory.getConnection();             PreparedStatement statement = connection.prepareStatement(INSERT_STATEMENT, Statement.RETURN_GENERATED_KEYS)) {            statement.setInt(1, client.getId());            statement.setString(2, client.getName());            statement.setString(3, client.getEmail());            statement.setString(4, client.getPhoneNumber());            statement.setString(5, client.getAddress());            statement.executeUpdate();            ResultSet resultSet = statement.getGeneratedKeys();            if (resultSet.next()) {                insertId = resultSet.getInt(1);            }        } catch (SQLException e) {            LOGGER.log(Level.WARNING, "ClientDAO:insert " + e.getMessage());        }        return insertId;    }    @Override    public Client updateCustomerById(int id, String name, String email, String phoneNumber, String address) {        Client client = null;        try (Connection connection = ConnectionFactory.getConnection();             PreparedStatement statement = connection.prepareStatement(UPDATE_STATEMENT, Statement.RETURN_GENERATED_KEYS)) {            statement.setString(1, name);            statement.setString(2, email);            statement.setString(3, phoneNumber);            statement.setString(4, address);            statement.setInt(5, id);            statement.executeUpdate();            ResultSet resultSet = statement.getGeneratedKeys();            if (resultSet.next()) {                int updatedId = resultSet.getInt(1);                client = new Client(updatedId, name, email, phoneNumber, address);            }        } catch (SQLException e) {            LOGGER.log(Level.WARNING, "ClientDAO:update " + e.getMessage());        }        return client;    }    @Override    public Client updateProductById(int id, String name, Double price, int stock) {        // This method is not implemented for the ClientDAO        return null;    }    @Override    public int delete(int id) {        int deleteId = -1;        try (Connection connection = ConnectionFactory.getConnection();             PreparedStatement statement = connection.prepareStatement(DELETE_STATEMENT, Statement.RETURN_GENERATED_KEYS)) {            statement.setInt(1, id);            statement.executeUpdate();            ResultSet resultSet = statement.getGeneratedKeys();            if (resultSet.next()) {                deleteId = resultSet.getInt(1);            }        } catch (SQLException e) {            LOGGER.log(Level.WARNING, "ClientDAO:delete " + e.getMessage());        }        return deleteId;    }    @Override    public ArrayList<Client> viewAll() {        ArrayList<Client> clients = new ArrayList<>();        try (Connection connection = ConnectionFactory.getConnection();             PreparedStatement statement = connection.prepareStatement(SELECT_ALL_STATEMENT);             ResultSet resultSet = statement.executeQuery()) {            while (resultSet.next()) {                int id = resultSet.getInt("id");                String name = resultSet.getString("name");                String email = resultSet.getString("email");                String phoneNumber = resultSet.getString("phoneNumber");                String address = resultSet.getString("address");                Client client = new Client(id, name, email, phoneNumber, address);                clients.add(client);            }        } catch (SQLException e) {            LOGGER.log(Level.WARNING, "ClientDAO:viewAll: " + e.getMessage());        }        return clients;    }    @Override    public JTable viewAll2(ArrayList<?> objects) {        String[] columnNames = {"ID", "Name", "Email", "Phone Number", "Address"};        DefaultTableModel tableModel = new DefaultTableModel(columnNames, 0);        for (Object object : objects) {            if (object instanceof Client) {                Client client = (Client) object;                Object[] rowData = {client.getId(), client.getName(), client.getEmail(), client.getPhoneNumber(), client.getAddress()};                tableModel.addRow(rowData);            }        }        return new JTable(tableModel);    }}